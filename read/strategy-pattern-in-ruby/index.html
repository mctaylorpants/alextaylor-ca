<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Nanoc 4.12.2">

    <title>alextaylor.ca - Design Patterns in Ruby: Strategy Pattern</title>

    <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.6/build/pure-min.css" integrity="sha384-Uu6IeWbM+gzNVXJcM9XV3SohHtmWE+3VGi496jvgX1jyvDTXfdK+rfZc8C1Aehk5" crossorigin="anonymous">
    <link rel="stylesheet" href="/stylesheet.css">
    <link rel="stylesheet" href="/code-highlighting.css">

    <!-- favicon generated by https://favicon.io/favicon-generator/ -->
    <!-- Font Copyright (c) 2010-2012, Vernon Adams (vern@newtypography.co.uk), with Reserved Font Names "Coda" -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta property="og:site_name" content="alextaylor.ca" />
    <meta property="og:type" content="article" />

    
      <meta property="og:image" content="https://alextaylor.ca/images/taylormade_og_image.png" />
      <meta property="og:title" content="Design Patterns in Ruby: Strategy Pattern" />
      <meta property="og:description" content="Originally published on Medium

Design patterns can be powerful conceptual models for thinking about how to solve problems in software development. Popularized in the ’90s by the Gang of Four, many..." />
      <meta property="og:url" content="https://alextaylor.ca/read/strategy-pattern-in-ruby/" />
      <meta name="twitter:card" content="summary_large_image"></meta>
    
  </head>
  <body>
    <div class="pure-g">
      <div class="pure-u-1 header">
        <div class="l-box">
          <h1>
            <a href="/">
              <span class="light">~/</span>taylormade
            </a>
          </h1>
          <hr />
        </div>
      </div>

      <div class="pure-u-1 content">
        <div class="l-box">
          
            <h1>Design Patterns in Ruby: Strategy Pattern</h1>
            <p class="post-meta">
              January 2, 2018
            </p>
          

          <p><em>Originally published on <a href="https://medium.com/rubyinside/design-patterns-in-ruby-strategy-pattern-17e2fa191d9c">Medium</a></em></p>

<p>Design patterns can be powerful conceptual models for thinking about how to solve problems in software development. <a href="https://en.wikipedia.org/wiki/Design_Patterns">Popularized in the ’90s by the Gang of Four</a>, many of them have remained relevant to this day.</p>

<p>They can also be great shortcuts for understanding the architecture of a system. As soon as you recognize the presence of a pattern, your mental model of that system snaps into focus, and you suddenly have a high-level idea of the structure while you wade through individual classes and methods.</p>

<p>When I’m learning new concepts and patterns, I always like having practical examples. Since I was brushing up on my patterns recently, I thought I would share a real-world example of the Strategy pattern at work in a popular Ruby library.</p>

<hr>

<h2 id="a-brief-overview-of-the-strategy-pattern">
<a href="#a-brief-overview-of-the-strategy-pattern"></a>A Brief Overview of the Strategy Pattern</h2>

<p>The funny thing about patterns is, abstract descriptions of them always sound impenetrable and intimidating. If you want to go into more depth, check out the <a href="https://en.wikipedia.org/wiki/Strategy_pattern">excellent Wikipedia article</a>.</p>

<p>Briefly, the Strategy pattern is most useful when you want to provide multiple ways of processing a request, without hard-coding knowledge about those different methods into the object that handles the request.</p>

<p>For a practical example, we’re going to look at <a href="https://github.com/plataformatec/devise">Devise</a>, and one of its dependencies, <a href="https://github.com/hassox/warden">Warden</a>.</p>

<h2 id="the-strategy-pattern-in-warden">
<a href="#the-strategy-pattern-in-warden"></a>The Strategy Pattern in Warden</h2>

<p><a href="https://github.com/hassox/warden">Warden</a> is a Ruby gem that provides authentication for Rack applications. It’s a dependency of <a href="https://github.com/plataformatec/devise">Devise</a>, which uses Warden under the hood to authenticate requests.</p>

<p>Warden provides mechanisms for authenticating a session, but it remains agnostic about how exactly to perform the authentication; it leaves that up to the client code. For example, Devise provides a <code>DatabaseAuthenticatable</code> strategy for authorizing against a username and password, and a <code>Rememberable</code> strategy for validating a pre-existing session cookie.</p>

<p>Here’s where we see the Strategy pattern at work; by keeping the authentication algorithms separate from the code that performs the authentication, new algorithms can be employed without modifying Warden itself, and Warden can select a “winning” strategy at runtime without knowledge of how the algorithm works.</p>

<p>This concept of multiple strategies is perhaps a slight twist on the classic Strategy pattern; instead of selecting a single algorithm at runtime based on characteristics of the incoming request, Warden loops through all the selected strategies until it finds one that works.</p>

<h2 id="lets-see-some-code">
<a href="#lets-see-some-code"></a>Let’s See Some Code</h2>

<p>It’s always useful seeing how these patterns are implemented. Let’s dive into Warden!</p>

<p><a href="https://github.com/wardencommunity/warden/blob/master/lib/warden/strategies/base.rb"><code>Warden::Strategies::Base</code></a> provides a common, abstract interface for all strategies to inherit from. Each strategy simply needs to implement its own authenticate! method, and Warden takes care of the rest.</p>

<p>For example, here’s what Devise’s <a href="https://github.com/plataformatec/devise/blob/master/lib/devise/strategies/database_authenticatable.rb">DatabaseAuthenticatable</a> strategy looks like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Devise</span>
  <span class="k">module</span> <span class="nn">Strategies</span>
    <span class="c1"># Default strategy for signing in a user, based on their email and password in the database.</span>
    <span class="k">class</span> <span class="nc">DatabaseAuthenticatable</span> <span class="o">&lt;</span> <span class="no">Authenticatable</span>
      <span class="k">def</span> <span class="nf">authenticate!</span>
        <span class="n">resource</span>  <span class="o">=</span> <span class="n">password</span><span class="p">.</span><span class="nf">present?</span> <span class="o">&amp;&amp;</span> <span class="n">mapping</span><span class="p">.</span><span class="nf">to</span><span class="p">.</span><span class="nf">find_for_database_authentication</span><span class="p">(</span><span class="n">authentication_hash</span><span class="p">)</span>
        <span class="n">hashed</span> <span class="o">=</span> <span class="kp">false</span>

        <span class="k">if</span> <span class="n">validate</span><span class="p">(</span><span class="n">resource</span><span class="p">){</span> <span class="n">hashed</span> <span class="o">=</span> <span class="kp">true</span><span class="p">;</span> <span class="n">resource</span><span class="p">.</span><span class="nf">valid_password?</span><span class="p">(</span><span class="n">password</span><span class="p">)</span> <span class="p">}</span>
          <span class="n">remember_me</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
          <span class="n">resource</span><span class="p">.</span><span class="nf">after_database_authentication</span>
          <span class="n">success!</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
        <span class="k">end</span>

        <span class="n">mapping</span><span class="p">.</span><span class="nf">to</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">password</span> <span class="o">=</span> <span class="n">password</span> <span class="k">if</span> <span class="o">!</span><span class="n">hashed</span> <span class="o">&amp;&amp;</span> <span class="no">Devise</span><span class="p">.</span><span class="nf">paranoid</span>
        <span class="nb">fail</span><span class="p">(</span><span class="ss">:not_found_in_database</span><span class="p">)</span> <span class="k">unless</span> <span class="n">resource</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here, we look up the “authenticatable” resource (usually a user) after verifying that a password was supplied. Then, we validate the password and call <code>#success!</code>, which Warden defines in the parent class. If the strategy was not successful — i.e. if the password was invalid — we <code>#fail</code> the strategy and allow Warden to attempt another method of authentication.</p>

<p>What does this look like from Warden’s perspective? When a request for authentication is triggered, it’s handled by <a href="https://github.com/hassox/warden/blob/master/lib/warden/proxy.rb">Warden::Proxy</a>.</p>

<p>In <code>#_run_strategies_for</code>, we iterate through the strategies set up for the resource and determine if any of them will provide access:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Run the strategies for a given scope</span>
<span class="k">def</span> <span class="nf">_run_strategies_for</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="c1">#:nodoc:</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">winning_strategy</span> <span class="o">=</span> <span class="vi">@winning_strategies</span><span class="p">[</span><span class="n">scope</span><span class="p">]</span>
  <span class="k">return</span> <span class="k">if</span> <span class="n">winning_strategy</span> <span class="o">&amp;&amp;</span> <span class="n">winning_strategy</span><span class="p">.</span><span class="nf">halted?</span>

  <span class="c1"># ...</span>
  
  <span class="p">(</span><span class="n">strategies</span> <span class="o">||</span> <span class="n">args</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
    <span class="n">strategy</span> <span class="o">=</span> <span class="n">_fetch_strategy</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">strategy</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strategy</span><span class="p">.</span><span class="nf">performed?</span> <span class="o">&amp;&amp;</span> <span class="n">strategy</span><span class="p">.</span><span class="nf">valid?</span>

    <span class="n">strategy</span><span class="p">.</span><span class="nf">_run!</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">winning_strategy</span> <span class="o">=</span> <span class="vi">@winning_strategies</span><span class="p">[</span><span class="n">scope</span><span class="p">]</span> <span class="o">=</span> <span class="n">strategy</span>
    <span class="k">break</span> <span class="k">if</span> <span class="n">strategy</span><span class="p">.</span><span class="nf">halted?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The Strategy pattern comes into play on line 12 above; <code>strategy._run!</code> ultimately calls <code>#authenticate!</code> in the strategy class.</p>

<p>We can see that the code in <code>#_run_strategies_for</code> is concerned with one thing: figuring out which of the many potential strategies will successfully authenticate the request. Imagine what this method would look like if it also contained the logic from those strategies. Imagine how difficult it would be to add a new one!</p>

<h2 id="separation-of-concerns">
<a href="#separation-of-concerns"></a>Separation of Concerns</h2>
<p>Used as it is here, the Strategy pattern provides a really nice interface between Warden, Devise, and your application, and allows each component to focus on a single responsibility. Warden concerns itself with the gory details of handling sessions in Rack. Devise hooks into Rails to provide user flows and other niceties. Strategies provide a plug-and-play interface that keeps those concerns separate.</p>

<hr>

<h2 id="conclusion">
<a href="#conclusion"></a>Conclusion</h2>

<p>Employing the Strategy pattern in your own code can be an effective way of managing complexity. It embraces polymorphism and allows your code to focus on sending messages instead of switching on type. It also emphasizes a separation of concerns; your client code doesn’t need to concern itself with the internals of multiple algorithms.</p>


        </div>
      </div>

      <div class="pure-u-1">
        
          <div class="l-box">
            <hr />

            <p class="light">
              <em>Keep reading:</em>
            </p>

            
              <a href=https://alextaylor.ca/read/focused-puts-debugging/>
                <div class="article-box">
                  ❮ Focused `puts` debugging with STDERR
                </div>
              </a>
            

            
              <a href=https://alextaylor.ca/read/finding-focus/>
                <div class="article-box" style="text-align: right">
                  Tips for Finding Focus ❯
                </div>
              </a>
            

            <a href="/archive">
              <div class="article-box" style="text-align: center">
                Archive
              </div>
            </a>
          </div>
        

        <div class="l-box">
          <hr />
          <p class="footer">
            &copy; 2023 <strong>Alex Taylor</strong>
          </p>
          <p class="footer">
            <a href="https://github.com/mctaylorpants">github</a>
            &middot;
            <a href="https://www.linkedin.com/in/alexmorgantaylor/">linkedin</a>
            &middot;
            <a href="https://x.com/mctaylorpants">x</a>
            &middot;
            <a rel="me" href="https://ruby.social/@alextaylor">mastodon</a>
          </p>
        </div>
      </div>
    </div>
  </body>
</html>
