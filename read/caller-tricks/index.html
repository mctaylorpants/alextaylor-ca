<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Nanoc 4.13.3">

    <title>alextaylor.ca - The hidden features of `caller`</title>

    <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.6/build/pure-min.css" integrity="sha384-Uu6IeWbM+gzNVXJcM9XV3SohHtmWE+3VGi496jvgX1jyvDTXfdK+rfZc8C1Aehk5" crossorigin="anonymous">
    <link rel="stylesheet" href="/stylesheet.css">
    <link rel="stylesheet" href="/code-highlighting.css">

    <!-- favicon generated by https://favicon.io/favicon-generator/ -->
    <!-- Font Copyright (c) 2010-2012, Vernon Adams (vern@newtypography.co.uk), with Reserved Font Names "Coda" -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <link rel="alternate" type="application/atom+xml" title="Atom feed" href="https://alextaylor.ca/atom.xml" />

    <meta property="og:site_name" content="alextaylor.ca" />
    <meta property="og:type" content="article" />

    
      <meta property="og:image" content="https://alextaylor.ca/images/taylormade_og_image.png" />
      <meta property="og:title" content="The hidden features of `caller`" />
      <meta property="og:description" content="I use Ruby’s caller feature a lot when I’m debugging and trying to figure out the stack trace of a particular code path. I used to think that it couldn’t do much beyond returning the full stack tra..." />
      <meta property="og:url" content="https://alextaylor.ca/read/caller-tricks/" />
      <meta name="twitter:card" content="summary_large_image"></meta>
    
  </head>
  <body>
    <div class="pure-g">
      <div class="pure-u-1 header">
        <div class="l-box">
          <h1>
            <a href="/">
              <span class="light">~/</span>taylormade
            </a>
          </h1>
          <hr />
        </div>
      </div>

      <div class="pure-u-1 content">
        <div class="l-box">
          
            <h1>The hidden features of `caller`</h1>
            <p class="post-meta">
              November 18, 2021
            </p>
          

          <p>I use Ruby’s <a href="https://ruby-doc.org/core-2.7.0/Kernel.html#method-i-caller"><code>caller</code></a> feature a lot when I’m debugging and trying to figure out the stack trace of a particular code path. I used to think that it couldn’t do much beyond returning the full stack trace as an Array. But it’s got some tricks!</p>

<p>Here’s the basic usage. Let’s say we’re debugging this code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Tea</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">tea_name</span><span class="p">)</span>
    <span class="vi">@tea_name</span> <span class="o">=</span> <span class="n">tea_name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">prepare</span>
    <span class="n">measure</span>
    <span class="n">steep</span>
    <span class="n">drink</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">measure</span>
    <span class="nb">puts</span> <span class="s2">"1 teaspoon per cup..."</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">steep</span>
    <span class="nb">puts</span> <span class="s2">"Pouring water and waiting 3.5 minutes..."</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">drink</span>
    <span class="nb">puts</span> <span class="s2">"Ssssip! Mmmm, </span><span class="si">#{</span><span class="vi">@tea_name</span><span class="si">}</span><span class="s2">."</span>
    <span class="nb">puts</span> <span class="nb">caller</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span> <span class="n">s</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">"  "</span><span class="p">)</span> <span class="p">}</span> <span class="c1"># padding</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Tea</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Assam"</span><span class="p">).</span><span class="nf">prepare</span>
</code></pre></div></div>

<p>When we run the file, now we can see how we got to <code>#drink</code>:</p>

<pre><code>$&gt; ruby tea.rb
1 teaspoon per cup...
Pouring water and waiting 3.5 minutes...
Ssssip! Mmmm, Assam.
  tea.rb:9:in `prepare'
  tea.rb:28:in `&lt;main&gt;'
</code></pre>

<h2 id="stacktrace-too-long-did-not-read">
<a href="#stacktrace-too-long-did-not-read"></a>Stacktrace too long; did not read</h2>

<p>Stacktraces can get pretty huge, especially if you’re debugging something in Rails. Sometimes you just need to know the last line from the stacktrace. You could address into the array from <code>caller</code>, but there’s another way:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">caller</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p><code>caller</code> can take two arguments: the starting index, and how many lines you want. <code>caller(1, 1)</code> returns an Array containing the last line of the stack trace. (<code>caller(0, 1)</code> would return the <em>current</em> line, which usually isn’t terribly useful.)</p>

<p>These two approaches - indexing the whole array vs. passing arguments - are <strong>not</strong> equivalent when it comes to performance. <code>caller</code> with arguments is significantly faster. <a href="#appendix-performance-of-caller">See the appendix below for proof</a>!</p>

<p>Anyway, when we run this, we get a more focused output:</p>

<pre><code>$&gt; ruby tea.rb
1 teaspoon per cup...
Pouring water and waiting 3.5 minutes...
Ssssip! Mmmm, Assam.
  tea.rb:9:in `prepare'
</code></pre>

<h2 id="sometimes-you-want-more-than-just-a-string">
<a href="#sometimes-you-want-more-than-just-a-string"></a>Sometimes, you want more than just a string</h2>

<p>If you want to extract the filename, line number etc. from each line, you could do a bunch of surgery on the string itself. Or, you could use <code>caller_locations</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">caller_locations</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p><code>caller_locations</code> has the same interface as <code>caller</code>, but it returns a <a href="https://ruby-doc.org/core-2.7.0/Thread/Backtrace/Location.html"><code>Thread::Backtrace::Location</code></a> instead of a String for each entry. Much easier than messing around with the string itself:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">loc</span> <span class="o">=</span> <span class="n">caller_locations</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="nb">puts</span> <span class="s2">"  --&gt; called from </span><span class="si">#{</span><span class="n">loc</span><span class="p">.</span><span class="nf">path</span><span class="si">}</span><span class="s2"> at line </span><span class="si">#{</span><span class="n">loc</span><span class="p">.</span><span class="nf">lineno</span><span class="si">}</span><span class="s2">"</span>
<span class="nb">puts</span> <span class="s2">"      (full path: </span><span class="si">#{</span><span class="n">loc</span><span class="p">.</span><span class="nf">absolute_path</span><span class="si">}</span><span class="s2">)"</span>
</code></pre></div></div>

<pre><code>$&gt; ruby tea.rb
1 teaspoon per cup...
Pouring water and waiting 3.5 minutes...
Ssssip! Mmmm, Assam.
  --&gt; called from tea.rb at line 9
      (full path: /Users/alextaylor/code/tea.rb)
</code></pre>

<h2 id="appendix-performance-of-caller">
<a href="#appendix-performance-of-caller"></a>Appendix: performance of <code>caller</code>
</h2>
<p>I had a feeling that passing arguments to <code>caller</code> would be more performant than indexing into the whole array, since presumably <code>caller</code> wouldn’t do the work of generating the whole stack trace if it didn’t need to. But I wanted to prove it, so I wrote a benchmarking script:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"benchmark/ips"</span>

<span class="no">MAX_METHODS</span> <span class="o">=</span> <span class="mi">5000</span>

<span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="no">MAX_METHODS</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">num</span><span class="o">|</span>
  <span class="n">define_method</span><span class="p">(</span><span class="s2">"method_</span><span class="si">#{</span><span class="n">num</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="k">do</span>
    <span class="nb">send</span><span class="p">(</span><span class="s2">"method_</span><span class="si">#{</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">define_method</span><span class="p">(</span><span class="s2">"method_</span><span class="si">#{</span><span class="no">MAX_METHODS</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">Benchmark</span><span class="p">.</span><span class="nf">ips</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"caller"</span><span class="p">)</span>       <span class="p">{</span> <span class="nb">caller</span> <span class="p">}</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"caller(1, 1)"</span><span class="p">)</span> <span class="p">{</span> <span class="nb">caller</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s2">"caller[0]"</span><span class="p">)</span>    <span class="p">{</span> <span class="nb">caller</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
    <span class="n">x</span><span class="p">.</span><span class="nf">compare!</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">method_0</span>
</code></pre></div></div>

<p>This script defines 5000 methods, each one calling the next, kind of like this:</p>

<pre><code>method_0 -&gt; method_1 -&gt; method_2 -&gt; etc..
</code></pre>

<p>On the last method, it benchmarks various approaches to fetching the stack trace. Here’s what we get:</p>

<pre><code>Warming up --------------------------------------
        caller(1, 1)     4.614k i/100ms
           caller[0]    24.000  i/100ms
              caller    23.000  i/100ms
Calculating -------------------------------------
        caller(1, 1)     48.644k (± 2.5%) i/s -    244.542k in   5.030285s
           caller[0]    234.556  (± 2.1%) i/s -      1.176k in   5.016163s
              caller    229.167  (± 3.1%) i/s -      1.150k in   5.023069s

Comparison:
        caller(1, 1):    48643.5 i/s
           caller[0]:      234.6 i/s - 207.39x  (± 0.00) slower
              caller:      229.2 i/s - 212.26x  (± 0.00) slower
</code></pre>

<p>As you can see, fetching the whole stack trace in this case is <strong>200x slower</strong> than looking up just what you need.</p>



        </div>
      </div>

      <div class="pure-u-1">
        
          <div class="l-box">
            <hr />

            <p>
              <em>Keep reading:</em>
            </p>

            
              <a href=https://alextaylor.ca/read/practicing-boundaries/>
                <div class="article-box">
                  ❮ Practicing boundaries
                </div>
              </a>
            

            
              <a href=https://alextaylor.ca/read/first-time-rails-contributor/>
                <div class="article-box" style="text-align: right">
                  Hello, Rails! My first Rails contribution ❯
                </div>
              </a>
            

            <a href="/archive">
              <div class="article-box" style="text-align: center">
                Archive
              </div>
            </a>
          </div>
        

        <div class="l-box">
          <hr />
          <p class="footer">
            &copy; 2025 <strong>Alex Taylor</strong>
          </p>
          <p class="footer">
            <a href="https://alextaylor.ca/atom.xml">atom feed</a>
          </p>
          <p class="footer">
            <a href="https://github.com/mctaylorpants">github</a>
            &middot;
            <a href="https://www.linkedin.com/in/alexmorgantaylor/">linkedin</a>
            &middot;
            <a href="https://x.com/mctaylorpants">x</a>
            &middot;
            <a rel="me" href="https://ruby.social/@alextaylor">mastodon</a>
          </p>
        </div>
      </div>
    </div>
  </body>
</html>
