<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Nanoc 4.12.2">

    <title>alextaylor.ca - Writing Neovim plugins with Ruby</title>

    <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.6/build/pure-min.css" integrity="sha384-Uu6IeWbM+gzNVXJcM9XV3SohHtmWE+3VGi496jvgX1jyvDTXfdK+rfZc8C1Aehk5" crossorigin="anonymous">
    <link rel="stylesheet" href="/stylesheet.css">
    <link rel="stylesheet" href="/code-highlighting.css">

    <!-- favicon generated by https://favicon.io/favicon-generator/ -->
    <!-- Font Copyright (c) 2010-2012, Vernon Adams (vern@newtypography.co.uk), with Reserved Font Names "Coda" -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta property="og:site_name" content="alextaylor.ca" />
    <meta property="og:type" content="article" />

    
      <meta property="og:image" content="https://alextaylor.ca/images/taylormade_og_image.png" />
      <meta property="og:title" content="Writing Neovim plugins with Ruby" />
      <meta property="og:description" content="I‚Äôve been using Neovim for years, but the other day I made a delightful discovery: you can write plugins in Ruby! There‚Äôs even an officially-supported library for it.

Let‚Äôs take it for a spin and ..." />
      <meta property="og:url" content="https://alextaylor.ca/read/writing-neovim-plugins-with-ruby/" />
      <meta name="twitter:card" content="summary_large_image"></meta>
    
  </head>
  <body>
    <div class="pure-g">
      <div class="pure-u-1 header">
        <div class="l-box">
          <h1>
            <a href="/">
              <span class="light">~/</span>taylormade
            </a>
          </h1>
          <hr />
        </div>
      </div>

      <div class="pure-u-1 content">
        <div class="l-box">
          
            <h1>Writing Neovim plugins with Ruby</h1>
            <p class="post-meta">
              November 6, 2022
            </p>
          

          <p>I‚Äôve been using <a href="https://neovim.io/">Neovim</a> for years, but the other day I made a delightful discovery: you can write plugins in Ruby! <a href="https://github.com/neovim/neovim-ruby">There‚Äôs even an officially-supported library for it</a>.</p>

<p>Let‚Äôs take it for a spin and see what it can do.</p>

<h2 id="the-unseen-hand-of-rpc">
<a href="#the-unseen-hand-of-rpc"></a>The unseen hand of RPC</h2>
<p>Neovim‚Äôs architecture supports the concept of remote plugins. These can be implemented as a process which receives RPC calls from the editor, and vice-versa.</p>

<p>neovim-ruby has a <a href="https://github.com/neovim/neovim-ruby#usage">small example</a> of how we can start a Ruby process and connect it to a running instance of Neovim. I took it a step further and used <a href="https://github.com/pry/pry">pry</a> so I could play around in a REPL:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env ruby</span>

<span class="nb">require</span> <span class="s2">"neovim"</span>
<span class="nb">require</span> <span class="s2">"pry"</span>

<span class="n">client</span> <span class="o">=</span> <span class="no">Neovim</span><span class="p">.</span><span class="nf">attach_unix</span><span class="p">(</span><span class="s2">"/tmp/nvim.sock"</span><span class="p">)</span>
<span class="nb">binding</span><span class="p">.</span><span class="nf">pry</span>
</code></pre></div></div>

<p>We can start Neovim and have it listen on the socket we specified‚Ä¶</p>

<pre><code>nvim --listen /tmp/nvim.sock
</code></pre>

<p>‚Ä¶ and then boot the Ruby console. And voila! We can drive Neovim from Ruby ü§©</p>

<p><img src="/images/neovim-in-ruby.png" alt="" class="pure-img"></p>

<p>neovim-ruby gives you a nice object-oriented interface into the editor. Here, <code>client</code> is Neovim itself, and I can access the currently-visible buffer with <code>get_current_buf</code>.</p>

<p>This is all well and good, but let‚Äôs have some more fun! Can we programatically insert a new line into the buffer? Of course we can:</p>

<p><img src="/images/the-unseen-hand-of-rpc.gif" alt="" class="pure-img"></p>

<hr>

<h2 id="writing-a-remote-plugin">
<a href="#writing-a-remote-plugin"></a>Writing a remote plugin</h2>
<p>Of course, booting a side process like this is fun, but not very practical. If we really want to drive Neovim with Ruby, we can write a remote plugin.</p>

<p>neovim-ruby lets us define a vim command as a block which will be called when that command is invoked in the editor. The ‚Äúhello world‚Äù looks like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Neovim</span><span class="p">.</span><span class="nf">plugin</span> <span class="k">do</span> <span class="o">|</span><span class="n">plug</span><span class="o">|</span>
  <span class="n">plug</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:HelloWorld</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">nvim</span><span class="o">|</span>
    <span class="n">nvim</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="s2">"echo 'Hello, world! üëã'"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<hr>

<p><img src="/images/neovim-hello-world.gif" alt="" class="pure-img"></p>

<p>Just like in our REPL, we‚Äôve got access to the Neovim client itself, as the first argument to the block. If our command took arguments, those would get passed too.</p>

<h2 id="evalruby-my-first-neovim-plugin">
<a href="#evalruby-my-first-neovim-plugin"></a>EvalRuby: my first Neovim plugin</h2>
<p>Armed with this newfound power, I was thinking of something interesting I could do.</p>

<p>I always liked the ‚Äúinline REPL‚Äù that Avdi Grimm uses for his <a href="https://graceful.dev/">Graceful.Dev</a> (formerly RubyTapas) screencasts. It lets him write a line of code in his editor, where it can be evaluated and returned as a comment. Kind of like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="c1"># =&gt; 2</span>
</code></pre></div></div>

<p>That sounds fun. Let‚Äôs build it!</p>

<p>First, we need to define our command. <strong>EvalRuby</strong> seems like a fitting name.</p>

<p>I want to be able to select one or more lines to evaluate, so my command will need to work on ranges. According to <a href="https://neovim.io/doc/user/map.html#E177">the Neovim docs</a>, we just need to declare this up front:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plug</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:EvalRuby</span><span class="p">,</span> <span class="ss">range: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">nvim</span><span class="p">,</span> <span class="n">range_start</span><span class="p">,</span> <span class="n">range_end</span><span class="o">|</span>

<span class="k">end</span>
</code></pre></div></div>

<p><code>range_start</code> and <code>range_end</code> will be the line numbers of the selection, or they‚Äôll
be the same if we‚Äôre only selecting a single line.</p>

<p>Next, we need to pull out the content so we can <code>eval</code> it! neovim-ruby gives us a handy <code>lines</code> array in the current buffer. Since this array will be zero-indexed, we need to account for that:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plug</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:EvalRuby</span><span class="p">,</span> <span class="ss">range: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">nvim</span><span class="p">,</span> <span class="n">range_start</span><span class="p">,</span> <span class="n">range_end</span><span class="o">|</span>
  <span class="n">ruby_code</span> <span class="o">=</span> <span class="n">nvim</span>
    <span class="p">.</span><span class="nf">get_current_buf</span>
    <span class="p">.</span><span class="nf">lines</span><span class="p">[(</span><span class="n">range_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">range_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now that we‚Äôve got the code, we have a legitimate excuse to use <code>eval</code>. Hopefully we trust our own input ü§ì</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plug</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:EvalRuby</span><span class="p">,</span> <span class="ss">range: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">nvim</span><span class="p">,</span> <span class="n">range_start</span><span class="p">,</span> <span class="n">range_end</span><span class="o">|</span>
  <span class="n">ruby_code</span> <span class="o">=</span> <span class="n">nvim</span>
    <span class="p">.</span><span class="nf">get_current_buf</span>
    <span class="p">.</span><span class="nf">lines</span><span class="p">[(</span><span class="n">range_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">range_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="k">begin</span>
             <span class="nb">eval</span> <span class="n">ruby_code</span>
           <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
             <span class="s2">"! </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2"> (</span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">)"</span>
           <span class="k">end</span>
</code></pre></div></div>

<p>To account for syntax errors, or lines that just aren‚Äôt Ruby, we can rescue any
errors and spit that out as a comment, too.</p>

<p>Now that we‚Äôve got the result, we can close the loop by appending it back
into our editor below the selection:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plug</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:EvalRuby</span><span class="p">,</span> <span class="ss">range: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">nvim</span><span class="p">,</span> <span class="n">range_start</span><span class="p">,</span> <span class="n">range_end</span><span class="o">|</span>
  <span class="n">ruby_code</span> <span class="o">=</span> <span class="n">nvim</span>
    <span class="p">.</span><span class="nf">get_current_buf</span>
    <span class="p">.</span><span class="nf">lines</span><span class="p">[(</span><span class="n">range_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">..</span><span class="p">(</span><span class="n">range_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="k">begin</span>
             <span class="nb">eval</span> <span class="n">ruby_code</span>
           <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
             <span class="s2">"! </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2"> (</span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">)"</span>
           <span class="k">end</span>

  <span class="n">nvim</span>
    <span class="p">.</span><span class="nf">get_current_buf</span>
    <span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">range_end</span><span class="p">,</span> <span class="s2">"# =&gt; </span><span class="si">#{</span><span class="n">result</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And, behold! It works great üéâ</p>

<p><img src="/images/neovim-evalruby.gif" alt="" class="pure-img"></p>

<h2 id="conclusion">
<a href="#conclusion"></a>Conclusion</h2>
<p>This was a fun project, and I think I‚Äôll actually get some use out of it, too; I often find myself jumping into IRB while I‚Äôm coding to try things out or demonstrate something while I‚Äôm pairing.</p>

<p>Now that I wield this power, I can see myself making all sorts of fun plugins.</p>

<p>If you want to check out the full code for EvalRuby, <a href="https://gist.github.com/mctaylorpants/04a9353583681f48d90d4ac9f58d3485">I‚Äôve put it up as a gist!</a></p>


        </div>
      </div>

      <div class="pure-u-1">
        <div class="l-box">
          <hr />
          <p class="footer">
            &copy; 2022 <strong>Alex Taylor</strong>
            &middot;
            <a href="https://github.com/mctaylorpants">github</a>
            &middot;
            <a href="https://www.linkedin.com/in/alexmorgantaylor/">linkedin</a>
            &middot;
            <a href="https://twitter.com/mctaylorpants">twitter</a>
            &middot;
            <a rel="me" href="https://ruby.social/@alextaylor">mastodon</a>
          </p>
        </div>
      </div>
    </div>
  </body>
</html>
